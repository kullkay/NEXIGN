Установка и настройка PT AI Plugin
==================================

Установка PT AI Plugin
----------------------

Чтобы установить плагин AI.Cli.Plugin:
1.  Установите последнюю версию Java JDK 8.
2.  Загрузите плагины с помощью Git: `git clone https://github.com/POSIdev-community/ptai-ee-tools`
3.  В командной строке перейдите в корень каталога с плагином и выполните:
    `gradlew build`, для сборки AI.Cli.Plugin.
    
    Плагины доступны по следующим пути:
    — `ptai-cli-plugin\build\libs\ptai-cli-plugin.jar`.

    Примечание. Если в процессе сборки вы получили ошибку, добавьте каталог с исходным
                кодом плагина в список исключений для вашего антивируса и повторите сборку. Если
                проблема не решится, обратитесь в Positive Technologies.

Настройка безопасное соединение
-------------------------------

1.  Импортируйте цепочку SSL-сертификатов удостоверяющего центра, выпустившего
    SSL-сертификат для PT AI Enterprise Server, или сам сертификат PT AI Enterprise Server
    (при использовании самоподписанного сертификата) в хранилище сертификатов Java.
    Вам потребуются сертификаты в кодировке Base64 (PEM-формат) и утилита `keytool`
    (входит в пакет Java JDK).

    Примечание. Если иерархия сертификатов, используемых для выпуска сертификата
                PT AI Enterprise Server, содержит Root CA и Intermediate CA как показано на рисунке
                ниже, необходимо экспортировать оба этих сертификата в кодировке Base64.
                
    Импортируйте сертификаты с использованием keytool (пример команды для ОС
    семейства Unix):
    ```
    keytool -importcert -keystore jdk1.8\jre\lib\security\cacerts -storepass "changeit" -alias
    AIRootCA -file RootCA.pem –noprompt
    keytool -importcert -keystore jdk1.8\jre\lib\security\cacerts -storepass "changeit" -alias
    AIIntermediateCA -file IntermediateCA.pem –noprompt
    ```
2.  Используйте параметр плагина `–truststore` для указания пути к PEM-файлу с цепочкой
    сертификатов сервера. Аналогично примеру выше вам потребуется экспортировать
    сертификаты в кодировке Base64, затем в текстовом редакторе соединить их в цепочку
    в обратном порядке: Intermediate → Root и сохранить в файл. Параметр нужно
    использовать для каждой команды запуска плагина.
3.  Используйте параметр плагина `--insecure` для работы без указания сертификата (не
    рекомендуется при развертывании в рабочей среде). При использовании этого
    параметра сохраняется возможность установки защищенного соединения с
    PT AI Enterprise Server, но не выполняется проверка принадлежности сертификата,
    предъявленного сервером в ходе установки SSL-соединения, этому серверу. Параметр
    нужно использовать для каждой команды запуска плагина.
4.  Использовать токен доступа. 
    [Инструкция по созданию токена](PTAI_Server/README.md#создание-токенов-доступа).

Проверьте соединение с PT AI Enterprise Server, выполнив команду:
```
java -jar ptai-cli-plugin.jar check-server --url=https://<Адрес PT AI Enterprise Server>
--token=<Ваш токен>
```

Подготовка команды запуска сканирования
---------------------------------------

Чтобы подготовить команду запуска сканирования:

1.  Укажите полный путь к плагину в вызове Java:
    ```
    java -jar ptai-cli-plugin.jar
    ```
2.  Определите способ настройки сканирования одним из параметров:
    * `ui-ast`, если проект сканирования создан в веб-интерфейсе PT AI Server;
    * `json-ast`, если при запуске плагина вы хотите указать конфигурационный файл и файл политики безопасности 
    
    Примечание! Для внедрения в CI лучше подходит вариант с настройкой проекте через конфигурационные
                файлы, так как это позволяет шаблонизи́ровать и автоматизиировать создание проектов.
                Поэтому в дальнейшем будет использоваться вариант с параметром `json-ast`.

3.  Для `json-ast`, в параметрах `--settings-json` и `--policy-json` укажите путь
    к [конфигурационному файлу](#подготовка-файла-settingsjson) и
    [файлу политики безопасности](#подготовка-файла-policyjson) (необязательно) в формате JSON.
4.  Укажите путь к каталогу с исходным кодом в параметре `--input`.
5.  Определите режим сканирования:
    * `--async` для сканирования в асинхронном режиме. В этом случае будет запущена
      проверка кода на наличие уязвимостей и сборка продолжится, не дожидаясь
      завершения проверки.
    * по умолчанию для сканирования в синхронном режиме. В этом случае будет запущена
      проверка кода на наличие уязвимостей и сборка не продолжится до тех пор, пока
      проверка не завершится.

      Примечание! При описании [архитектуры](../README.md#архитектура) определили, что будем
                  использовать асинхронный режим.

6.  Укажите требования к отчету об уязвимостях:
    * Для формирования одного отчета укажите параметры из таблицы ниже.
    * Для формирования нескольких отчетов укажите требования в JSON-файле и задайте
      путь к нему в параметре `--report-json`. Синтаксис файла приведен в [параграфе](#подготовка-файла-reportjson).


7.  Укажите параметры подключения к PT AI Server:
    `--url` — адрес PT AI Enterprise Server.
    `--token` — токен доступа для плагинов CI/CD. 
    [Инструкция по созданию токена](PTAI_Server/README.md#создание-токенов-доступа).
8.  Укажите каталог для сохранения отчетов по результатам сканирования в параметре `--output`
    (по умолчанию используется каталог `.ptai`).
    
    Примечание. Во всех режимах работы плагин создает файл `rest.url` со ссылкой на
                результаты сканирования в формате JSON. Для открытия этой ссылки необходимо
                использовать токен доступа, который можно получить через API.
            
9.  С помощью параметров `--includes` и `--excludes` добавьте или исключите
    определенные файлы из сканирования по маске. Используется синтаксис Apache Ant.
    
    Например можно исключить:
    - `**/*test*/**` -- папку с тестами
    - `**/.*/**` -- скрытые ресурсы, однако необходимо будет в параметре `--includes` указать файл
                    `**/.gitignore`, так как он может использоваться для сканирования в PT AI.

10. Выполните получившуюся команду.
    Если все параметры указаны корректно, отобразится уведомление о постановке
    сканирования в очередь, как показано на рисунке ниже.

    ![](../.media/start_plagin.png)

Примеры команд запуска плагина. Проект создается на основе файла конфигурации, асинхронный запуск:
```
java -jar ptai-cli-plugin.jar json-ast
--input="/home/folder"
--settings-json=ai-settings.json
--policy-json=ai-policy.json
--async
--excludes=**/test/**,**/assets/**
--output="/home/pt-reports"
--url=https://ptaisrv.domain.org
--token=yourtoken
```

| Формат отчета                   | Параметр                 | Возможные значения                                                                 |
|----------------------------------|--------------------------|-------------------------------------------------------------------------------------|
| HTML                             | --report-template         | Список возможных значений представлен в веб-интерфейсе PT AI Server в разделе Шаблоны отчетов |
|                                  | --report-file             | Имя файла                                                                          |
|                                  | --report-include-dfd      | True или false                                                                    |
|                                  | --report-includeglossary  | True или false                                                                    |
| SARIF                            | --sarif-report-file       | Имя файла                                                                          |
| SonarGiif                        | --giif-report-file        | Имя файла                                                                          |
| Необработанные данные в формате JSON | --raw-data-file        | Имя файла                                                                          |

Создание отчетов по результатам сканирования
--------------------------------------------

Чтобы создать отчет по результатам сканирования в асинхронном режиме:
1.  Укажите полный путь к плагину в вызове Java и параметр для создания отчетов
generate-report:
    ```
    java -jar ptai-cli-plugin.jar generate-report
    ```
1.  Укажите идентификатор проекта (`--project-id`) или его имя (`--project-name`).
    Примечание. Плагин генерирует файл `rest.url`, который содержит идентификатор
                проекта для автоматической подстановки этого параметра в скриптах.
2.  Укажите идентификатор результата сканирования (`--scan-result-id`).
   
    Примечание. Вы можете скопировать его из вывода плагина при постановке задачи
                сканирования в очередь, либо из файла `rest.url`. Если параметр не указан, будет
                выгружен результат последнего сканирования указанного проекта.
    
3.  Укажите параметры для создания отчета, описанные на раздела [«Подготовка команды запуска плагина»](#подготовка-команды-запуска-сканирования).

4.  Укажите параметры для подключения к PT AI Server:
    • `--url` — адрес PT AI Server;
    • `--token` — токен доступа для плагинов CI/CD.

Пример команды на создание отчетов:
```
java -jar ptai-cli-plugin.jar generate-report --project-id=projectUUID scanresult-id=resultUUID --report-json=ai-report.json --url=https://
ptaisrv.domain.org --token=yourtoken
```

Подготовка файла settings.json
------------------------------

Основные параметры сканирования:

- `$schema` -- Cылка на JSON-схему, описывающая конфигурационный файл.

- `Version` -- Версия конфигурационного файла.

- `ProjectName` -- Название проекта.
  
  Примечание! Название проекта должно быть уникальным. 
  
  Поэтому, предлагаю строить имя проекта следующим образом: `{$NameProject}-{$NameBranch}-{$id}`. Где:
  
  * `{$NameProject}` - название проекта, который отправляется на сканирование;
  * `{$NameBranch}` - название ответвления разработки;
  * `{$id}` - уникальный идентификатор. Например id последнего commit.

- `ProgrammingLanguages` -- Стек анализируемых языков. Возможные значения: Java,
  CSharp (Windows, Linux), CSharp (Windows), VB, Php, JavaScript, Python, ObjectiveC, Swift,
  CAndCPlusPlus, Go, Kotlin, Sql, Ruby

  Примечание! Хоть в PT AI есть возможность автоматического распознавания языков, однако лучше для
              проектов на С++ и Java создавать проекты, в которых будут участвовать только один из них.

- `ScanModules` --Модули поиска уязвимостей: Configuration, Components, BlackBox, PatternMatching,
  StaticCodeAnalysis

- `SkipGitIgnoreFiles` -- Флаг для исключения файлов и папок, указанные в .gitignore.
  
- `MailingProjectSettings` -- Параметры для настройки отправки почтовых отчетов.
  
- `UseSecurityPolicies` -- Флаг для использование политик безопасности
  
- `UseSastRules` -- Флаг для использование правил анализа SAST 

- `UseCustomPmRules` -- Флаг для использование правил анализа по пользовательским шаблонам 

- `JavaSettings` -- Параметры настройки анализа Java кода:
  
  * `Parameters` -- Параметры запуска Java Virtual Machine
  * `UnpackUserPackages` -- Флаг для распаковки пользовательских JAR-файлов
  * `UserPackagePrefixes` -- Префиксы пользовательских пакетов
  * `Version` -- Версия JDK: 8, 11, 17
  * `CustomParameters` -- Дополнительные параметры запуска модуля анализа
  * `DownloadDependencies` -- Флаг для загружать зависимости
  * `UsePublicAnalysisMethod` -- Флаг для поиска от доступных методов public и protected

- `CAndCPlusPlus` -- Параметры настройки анализа Java кода:
  
  * `Parameters` -- Параметры запуска
  * `CustomParameters` -- Дополнительные параметры запуска модуля анализа
  * `DownloadDependencies` -- Флаг для загружать зависимости
  * `UsePublicAnalysisMethod` -- Флаг для поиска от доступных методов public и protected

Подготовка файла report.json
----------------------------

Конфигурационный файл состоит из четырех секций, ни одна из секций не является
обязательной и может быть пропущена:
— report: [...] — отчет в форматах HTML;
— sarif: [...] — отчет в формате SARIF;
— sonarGiif: [...] — отчет для SonarQube;
— raw: [...] — необработанные данные в формате JSON.

Описание секции `report`

| Параметр         | Описание                                                                 |
|------------------|--------------------------------------------------------------------------|
| `fileName`       | Название файла с отчетом                                                 |
| `includeDfd`     | Добавить в отчет диаграмму потоков данных (по умолчанию `true`)          |
| `includeGlossary`| Добавить в отчет справочную информацию об уязвимостях (по умолчанию `true`) |
| `template`       | Шаблон отчета (см. веб-интерфейс PT AI Enterprise Edition)                |
| `filters`        | Фильтры                                                                   |

---

Описание секций `sarif`, `sonarGiif` и `raw`

| Параметр   | Описание                           |
|------------|------------------------------------|
| `fileName` | Название файла с отчетом           |
| `filters`  | Фильтры                             |

---

Фильтры

| Параметр               | Описание                                                                 |
|------------------------|--------------------------------------------------------------------------|
| `issueLevel`           | Уровень опасности уязвимости:<br>— `ALL` (по умолчанию)<br>— `LOW`<br>— `MEDIUM`<br>— `HIGH`<br>— `POTENTIAL` |
| `actualStatus`         | Актуальность:<br>— `ALL` (по умолчанию)<br>— `ISNEW` — новые<br>— `NOTISNEW` — из предыдущих сканирований |
| `hideSecondOrder`      | Скрыть уязвимости второго порядка: `true` / `false`                     |
| `hideSuspected`        | Скрыть подозрения на уязвимости: `true` / `false`                       |
| `byBestPlaceToFix`     | Только без места исправления: `true` / `false`                          |
| `issueLevels`          | Уровень опасности (массив значений)                                     |
| `exploitationCondition`| Способ эксплуатации:<br>— `ALL` (по умолчанию)<br>— `NOCONDITION`<br>— `UNDERCONDITION` |
| `scanMode`             | Режим сканирования:<br>— `ALL` (по умолчанию)<br>— `FROMENTRYPOINT`<br>— `FROMPUBLICPROTECTED`<br>— `FROMOTHER` |
| `scanModes`            | Режимы сканирования (массив значений)                                   |
| `suppressStatus`       | Исключенные уязвимости:<br>— `EXCEPTSUPPRESSED` (по умолчанию)<br>— `SUPPRESSED`<br>— `ALL` |
| `confirmationStatus`   | Статус подтверждения:<br>— `UNDEFINED` (по умолчанию)<br>— `APPROVED`<br>— `AUTOAPPROVED`<br>— `DISCARDED`<br>— `ALL` |
| `confirmationStatuses` | Статусы подтверждения (массив значений)                                 |
| `sourceType`           | Метод анализа:<br>— `ALL` (по умолчанию)<br>— `STATIC`<br>— `BLACKBOX`   |


Подготовка файла policy.json
----------------------------

В процессе сборки проекта агент сборки проверяет соответствие результатов сканирования
заданным в правиле условиям и прекращает сборку, если политика нарушена.

Формат записи правила срабатывания политики безопасности

| Название раздела | Название строки   | Описание строки                                                                                                                                     |
|------------------|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| —                | `Policy ID`       | Произвольное строковое обозначение (необязательное, но уникальное)                                                                                 |
| —                | `CountToActualize`| Минимально необходимое количество срабатываний политики на найденных уязвимостях (если `0` или не задано — достаточно одного срабатывания)        |
| —                | `Scopes`          | Наборы правил. Политика сработает, если **хотя бы один набор актуален**                                                                            |
| `Scope`          | `Rules`           | Список правил внутри набора. Набор считается актуальным, если **для всех правил найдены уязвимости**                                               |
| `Rule`           | `Field`           | Название поля уязвимости                                                                                                                            |
|                  | `Value`           | Значение поля, требуемое для срабатывания правила. Сравнение регистронезависимое, если не используется `IsRegex`                                   |
|                  | `IsRegex`         | Флаг, указывающий, использовать ли регулярное выражение при сравнении (`true` / `false`)                                                            |

---

Основные значения строки `Field`

| Значение              | Тип данных         | Описание                                                                                                                                 |
|-----------------------|--------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| `ApprovalState`       | Число              | Статус подтверждения уязвимости:<br>0 — без статуса<br>1 — подтверждена<br>2 — опровергнута<br>3 — не существует<br>4 — авто-подтверждена |
| `EntryPointFile`      | Строка             | Путь до файла с точкой входа                                                                                                             |
| `EntryPointValue`     | Строка             | Имя функции или метода — точки входа                                                                                                     |
| `IsSecondOrder`       | Логическое значение| Наличие признака уязвимости второго порядка: `true` / `false`                                                                           |
| `IsSuspected`         | Логическое значение| Подозрение на уязвимость: `true` / `false`                                                                                               |
| `IsSuppressed`        | Логическое значение| Скрытая уязвимость: `true` / `false` (по умолчанию учитываются в политике)                                                              |
| `VulnerabilityLevel`  | Строка             | Уровень опасности: `high`, `medium`, `low`, `potential`                                                                                 |
| `SearchAlgorithm`     | Число              | Метод анализа:<br>0 — от точек входа (`FromEntryPoint`)<br>1 — от public/protected (`FromPublicProtected`)<br>2 — `Taint`<br>999 — неизвестно |
| `VulnerabilityTitle`  | Строка             | Название типа уязвимости                                                                                                                 |
| `VulnerableFile`      | Строка             | Путь к файлу с точкой выхода                                                                                                             |
| `VulnerableValue`     | Строка             | Имя функции или метода — точки выхода                                                                                                    |
| `Exploit`             | Строка             | Запрос, демонстрирующий уязвимость                                                                                                       |
| `VulnerableFunction`  | Строка             | Название уязвимой функции                                                                                                                |
| `Payload`             | Строка             | Параметры вектора атаки                                                                                                                  |
| `IsNew`               | Логическое значение| Флаг новой уязвимости: `true` / `false`

Примечание! Необходимо добавлять только на поздних этапах внедрения, когда уже все уязвимости размечены
            и необходимо отслеживать появление новых.

[Пример правила для поиска уязвимостей высокой опасности, исключая «Опровергнутые» и
«Подозрения на уязвимость»](./example_ai-policy.json).